package standrews.cs5099.mpp.tasks;

import java.util.List;
import java.util.Stack;
import java.util.concurrent.ExecutorService;

import standrews.cs5099.mpp.core.TaskExecutor;
import standrews.cs5099.mpp.core.WorkerService;
import standrews.cs5099.mpp.instructions.Instruction;

public class PipelineTask implements Runnable {

	// Actual data to be executed
	private Object data;

	// Parent Task
	private PipelineTask parentTask;
	// Root Task
	private PipelineTask rootTask;

	// List of child task generated by current task
	private List<PipelineTask> childTasks;
	// ExecutorService responsible for executing task
	private TaskExecutor assignedTaskExecutor;
	// Future object which holds result of computation
	private TaskFuture taskFuture;
	// Execution to be executed by the task
	private Instruction instruction;

	/**
	 * Constructor for Root Task
	 * 
	 * @param data
	 * @param assignedTaskExecutor
	 */
	public PipelineTask(Object data, ExecutorService assignedTaskExecutor, Instruction instruction) {
		this.data = data;
		this.rootTask = this;
		this.assignedTaskExecutor = (TaskExecutor) assignedTaskExecutor;
		this.instruction = instruction;
		this.taskFuture = new TaskFuture(this.assignedTaskExecutor, this);
	}

	/**
	 * Constructor for Child Tasks
	 */
	public PipelineTask(Object data, ExecutorService assignedTaskExecutor, Instruction instruction, PipelineTask parent) {
		this.data = data;
		this.rootTask = parent;
		this.assignedTaskExecutor = (TaskExecutor) assignedTaskExecutor;
		this.instruction = instruction;
		this.taskFuture = new TaskFuture(this.assignedTaskExecutor, this);
	}

	/**
	 * Returns true if current task is a Root task (a Task with no parent)
	 * 
	 * @return
	 */
	public boolean isRootTask() {
		return (parentTask == null);
	}

	/**
	 * Method which is invoked by an thread issued by the executor service
	 * 
	 */
	@Override
	public void run() {
		//
		System.out.println("Wow task is being executed");
		WorkerService.executePipelineTask(this);
		
		/*
		if(rootTask.equals(this)) {
			System.out.println("Root task is being executed");
			WorkerService.pipelineWorker(this);
		}
		*/
		
		
		/**
		 * O result = (O) WorkerService.executeTask(this); return null;
		 **/
	}

	public boolean isTaskFinished() {
		/** dummy return value **/
		return true;
	}

	public TaskFuture getFuture() {

		return rootTask.taskFuture;
	}

	public PipelineTask getParentTask() {
		return this.parentTask;
	}

	/**
	 * Fetch data field of a Task
	 * 
	 * @return
	 */
	public Object getData() {
		return data;
	}

	/**
	 * Update the data field of the Task
	 * 
	 * @param data
	 */
	public void setData(Object data) {
		this.data = data;
	}

	public PipelineTask getRootTask() {
		return rootTask;
	}

	public void setRootTask(PipelineTask rootTask) {
		this.rootTask = rootTask;
	}
	
	
	public List<PipelineTask> getChildTasks() {
		return childTasks;
	}

	public void setChildTasks(List<PipelineTask> childTasks) {
		this.childTasks = childTasks;
	}

	public TaskExecutor getAssignedTaskExecutor() {
		return assignedTaskExecutor;
	}

	public void setAssignedTaskExecutor(TaskExecutor assignedTaskExecutor) {
		this.assignedTaskExecutor = assignedTaskExecutor;
	}

	public void setParentTask(PipelineTask parentTask) {
		this.parentTask = parentTask;
	}

	public synchronized boolean areChildTasksFinished() {
		// dummy value
		return true;
	}

	public synchronized boolean hasChildTasks() {
		return (null != childTasks && childTasks.size() > 0);
	}

	public Instruction getInstruction() {
		return instruction;
	}

	public void setInstruction(Instruction instruction) {
		this.instruction= instruction;
	}
}
